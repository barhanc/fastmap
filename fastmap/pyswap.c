#include <Python.h>
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "lapi.h"

#define swap(type, x, y) \
    {                    \
        type SWAP = x;   \
        x = y;           \
        y = SWAP;        \
    }

/**
 * @brief Implementation of a brute-force algorithm solving the following combinatorial optimization
 * problem equivalent to computing isomorphic swap distance
 * ```
 *  min_{v ∈ S_nv} min_{σ ∈ S_nc} sum_{i=0,..,nv-1} sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} d(i,v(i),k,l,σ(k),σ(l))
 * ```
 * where d(i,j,k,l,m,n) := 1/2 * { (pos_U[i,k] - pos_U[i,l]) * (pos_V[j,m] - pos_V[j,n]) < 0 }
 * ({...} denoting here the Iverson bracket), nc is the number of candidates, nv is the number of
 * voters, pos_U[i,k] denotes the position of k-th candidate in the i-th vote in the U election and
 * S_n denotes the set of all permutations of the set {0,..,n-1}. The algorithm generates all
 * permutations of S_nc using Heap's algorithm and for every generated permutation σ solves the
 * corresponding Linear Assignment Problem (LAP) in order to find the optimal permutation v. We use
 * a dynamic approach to update cost matrix for LAP in O(nv**2 * nc). Indeed let s and s' be two
 * subsequent permutations generated by Heap's algorithm then there are two indices p!=q such that
 * ```
 * forall r=0,..,nc-1, r!=p, r!=q : s'(r) = s(r)
 * ```
 * and s'(p) = s(q) and s'(q) = s(p). Let c' = cost[i,j] and c = cost[i,j] denote the (i,j) element
 * of the cost matrix in two subsequent iterations of Heap's algorithm then (for simplicity we drop
 * the i,j when writing the element of the cost array d(i,j,k,l,m,n))
 * ```
 *  c' = sum_{k=0,..,nc-1} [
 *          sum_{l=0,..,nc-1} d(k,l,s'(k),s(l))
 *          - d(k,p,s'(k),s(p))
 *          - d(k,q,s'(k),s(q))
 *          + d(k,p,s'(k),s(q))
 *          + d(k,q,s'(k),s(p)) ]
 * ```
 * and doing some simple but tedious algebra we obtain
 * ```
 * c' = c
 *      - 2 * sum_{l=0,..,nc-1} [ d(p,l,s(p),s(l)) + d(q,l,s(q),s(l)) ]
 *      + 2 * sum_{l=0,..,nc-1} [ d(p,l,s(q),s(l)) + d(q,l,s(p),s(l)) ]
 *      + 2 * d(p,q,s(p),s(q))
 *      + 2 * d(p,q,s(q),s(p))
 * ```
 * where we used the following properties of the 6-D array d(i,j,k,l,m,n)
 * ```
 * forall i,j,k,l,m,n : d(i,j,k,l,m,n) = d(i,j,l,k,n,m)
 * forall i,j,k,l,x   : d(i,j,x,x,k,l) = d(i,j,k,l,x,x) = 0
 * ```
 * Therefore we can see that we can calculate element (i,j) of the matrix cost' as
 * ```
 * cost'[i,j] = cost[i,j]
 *              + sum_{k=0,..,nc-1}[ {(pos_U[i,p] - pos_U[i,k]) * (pos_V[j,s(q)] - pos_V[j,s(k)]) < 0}
 *                                   + {(pos_U[i,q] - pos_U[i,k]) * (pos_V[j,s(p)] - pos_V[j,s(k)]) < 0}
 *                                   - {(pos_U[i,p] - pos_U[i,k]) * (pos_V[j,s(p)] - pos_V[j,s(k)]) < 0}
 *                                   - {(pos_U[i,q] - pos_U[i,k]) * (pos_V[j,s(q)] - pos_V[j,s(k)]) < 0} ]
 *               + {(pos_U[i,p] - pos_U[i,q]) * (pos_V[j,s(p)] - pos_V[j,s(q)]) < 0}
 *               + {(pos_U[i,p] - pos_U[i,q]) * (pos_V[j,s(p)] - pos_V[j,s(q)]) > 0}
 * ```
 * and thus can update the whole `cost` matrix in O(nv**2 * nc).
 *
 * @param pos_U pointer to the linearized position matrix of the 1st (U) election i.e. a matrix such
 * that pos_U[i,k] denotes the position of k-th candidate in the i-th vote in the U election. NOTE:
 * we assume that the elements of matrix are stored in column-major order.
 *
 * @param pos_V pointer to the linearized position matrix of the 2nd (V) election i.e. a matrix such
 * that pos_V[i,k] denotes the position of k-th candidate in the i-th vote in the V election. NOTE:
 * we assume that the elements of matrix are stored in column-major order.
 *
 * @param nv number of votes
 * @param nc number of candidates
 * @return isomorphic swap distance
 */
static int32_t
swap_bf (const int32_t *pos_U, const int32_t *pos_V, const size_t nv, const size_t nc)
{
    // Cost matrix for LAP
    int32_t *cost = calloc (nv * nv, sizeof (int32_t));
    for (size_t k = 0; k < nc; k++)
        for (size_t l = k; l < nc; l++)
            for (size_t i = 0; i < nv; i++)
            {
                register int32_t r1 = pos_U[i + k * nv] - pos_U[i + l * nv];

                for (size_t j = 0; j < nv; j++)
                    cost[i * nv + j] += (r1 * (pos_V[j + k * nv] - pos_V[j + l * nv]) < 0);
            }

    // Stack pointer and encoding of the stack in iterative version of Heap's algorithm. See:
    // https://en.wikipedia.org/wiki/Heap%27s_algorithm
    size_t alpha = 1, *stack = calloc (nc, sizeof (size_t));

    // Permutation array initialized to identity permutation
    size_t *sigma = calloc (nc, sizeof (size_t));
    for (size_t i = 0; i < nc; i++)
        sigma[i] = i;

    // Indices of elements of permutation sigma which are swapped in the given iteration of Heap's
    // algorithm
    size_t p = 0, q = 0;

    // Auxiliary variables required for J-V LAP algorithm
    int32_t *x = calloc (nv, sizeof (int32_t));
    int32_t *y = calloc (nv, sizeof (int32_t));

    int32_t best_res = lapi (nv, cost, x, y);

    while (alpha < nc)
    {
        if (stack[alpha] < alpha)
        {
            if (alpha % 2 == 0)
                p = 0, q = alpha;
            else
                p = alpha, q = stack[alpha];

            for (size_t k = 0; k < nc; k++)
                for (size_t i = 0; i < nv; i++)
                {
                    register int32_t r1 = pos_U[i + p * nv] - pos_U[i + k * nv];
                    register int32_t r2 = pos_U[i + q * nv] - pos_U[i + k * nv];

                    for (size_t j = 0; j < nv; j++)
                    {
                        int32_t r3 = pos_V[j + sigma[q] * nv] - pos_V[j + sigma[k] * nv];
                        int32_t r4 = pos_V[j + sigma[p] * nv] - pos_V[j + sigma[k] * nv];

                        cost[i * nv + j] += (r1 * r3 < 0) + (r2 * r4 < 0) - (r1 * r4 < 0) - (r2 * r3 < 0);
                    }
                }

            for (size_t i = 0; i < nv; i++)
            {
                register int32_t r1 = pos_U[i + q * nv] - pos_U[i + p * nv];

                for (size_t j = 0; j < nv; j++)
                {
                    int32_t r2 = pos_V[j + sigma[q] * nv] - pos_V[j + sigma[p] * nv];

                    cost[i * nv + j] += (r1 * r2 < 0) + (r1 * r2 > 0);
                }
            }

            int32_t res = lapi (nv, cost, x, y);
            best_res = res < best_res ? res : best_res;

            swap (size_t, sigma[p], sigma[q]);
            stack[alpha]++;
            alpha = 1;
        }
        else
        {
            stack[alpha] = 0;
            alpha++;
        }
    }

    free (cost);
    free (stack);
    free (sigma);
    free (x);
    free (y);

    return best_res;
}

static const size_t pow10[] = {
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000,
    1000000000,
};

/**
 * @brief Computes the number of inversions (see:
 * https://en.wikipedia.org/wiki/Inversion_(discrete_mathematics) ) for every permutation p of set
 * {0,..,n-1} and stores the result in `mem` array under index E(p) where E is an encoding of p
 * ```
 *  E(p) := 10**0 * p[0] + 10**1 * p[1] + ... + 10**(n-2) * p[n-2] .
 * ```
 * Notice here that specifying n-1 elements of p already uniquely defines p.
 *
 * NOTE: we assume that n <= 10, otherwise the encoding E would not be unique. Notice also that we
 * could use a larger base (e.g. 11, 12) but for n=10 we already need to alocate 10**9B = 1GB
 * memory, thus using this method for larger permutations would require too much memory.
 *
 * @param n number of elements of permutation
 * @param mem pointer to an array used as a lookup table
 */
static void
mem_inversion_cnt (size_t n, uint8_t *mem)
{
    // Stack pointer and encoding of the stack in iterative version of Heap's algorithm. See:
    // https://en.wikipedia.org/wiki/Heap%27s_algorithm
    size_t alpha = 1, *stack = calloc (n, sizeof (size_t));

    // Permutation array initialized to identity permutation
    size_t *sigma = calloc (n, sizeof (size_t));
    for (size_t i = 0; i < n; i++)
        sigma[i] = i;

    // Indices of elements of permutation sigma which are swapped in the given iteration of Heap's
    // algorithm
    size_t p = 0, q = 0;

    while (alpha < n)
    {
        if (stack[alpha] < alpha)
        {
            if (alpha % 2 == 0)
                p = 0, q = alpha;
            else
                p = alpha, q = stack[alpha];

            swap (size_t, sigma[p], sigma[q]);

            uint8_t inversions = 0;
            for (size_t i = 0; i < n - 1; i++)
                for (size_t j = i + 1; j < n; j++)
                    inversions += sigma[i] > sigma[j] ? 1 : 0;

            size_t key = 0;
            for (size_t i = 0; i < n - 1; i++)
                key += sigma[i] * pow10[i];
            mem[key] = inversions;

            stack[alpha]++;
            alpha = 1;
        }
        else
        {
            stack[alpha] = 0;
            alpha++;
        }
    }

    free (stack);
    free (sigma);

    return;
}

/**
 * @brief Implementation of a brute-force algorithm solving the following combinatorial optimization
 * problem equivalent to computing isomorphic swap distance
 * ```
 *  min_{v ∈ S_nv} min_{σ ∈ S_nc} sum_{i=0,..,nv-1} sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} d(i,v(i),k,l,σ(k),σ(l))
 * ```
 * where d(i,j,k,l,m,n) := 1/2 * { (pos_U[i,k] - pos_U[i,l]) * (pos_V[j,m] - pos_V[j,n]) < 0 }
 * ({...} denoting here the Iverson bracket), nc is the number of candidates, nv is the number of
 * voters, pos_U[i,k] denotes the position of k-th candidate in the i-th vote in the U election and
 * S_n denotes the set of all permutations of the set {0,..,n-1}. The algorithm generates all
 * permutations of S_nc using Heap's algorithm and for every generated permutation σ solves the
 * corresponding Linear Assignment Problem (LAP) in order to find the optimal permutation v.
 *
 * This implementation is different from `swap_bf()` in that it uses a precomputed lookup table
 * which allows for O(nv**2) update of the `cost` matrix. Let's first notice that the expression for
 * (i,j) element of cost matrix (given candidates' permutation s) is permutation invariant, namely
 * for any permutation π ∈ S_nc we have
 * ```
 *  cost[i,j] = sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} 1/2 * {(pos_U[i, k   ] - pos_U[i, l   ]) * (pos_V[j, s(k)   ] - pos_V[j, s(l)   ]) < 0}
 *            = sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} 1/2 * {(pos_U[i, π(k)] - pos_U[i, π(l)]) * (pos_V[j, s(π(k))] - pos_V[j, s(π(l))]) < 0} .
 * ```
 * Indeed in both cases we sum the expression d(i,j,k,l,s(k),s(l)) over all pairs (k,l), however in
 * the first case we do it in the (0,0), (0,1), ..., (nc-1, nc-1) order and in the second case in
 * the (π(0), π(0)), (π(0), π(1)), ..., (π(nc-1), π(nc-1)) order. Therefore using π = U[i,:] we can
 * write
 * ```
 *  cost[i,j] = sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} 1/2 * {(k - l) * (pos_V[j, s(U[i,k])] - pos_V[j, s(U[i,l])]) < 0}
 *            = sum_{k=0,..,nc-1} sum_{l=k+1,..,nc-1} { pos_V[j,s(U[i, k])] < pos_V[j, s(U[i,l])] } .
 * ```
 * where we observed that pos_U[i, U[i,k]] = k and also note the changed limits of the summation
 * over l. We are therefore looking for a number of inversions of the permutation
 * ```
 * ( pos_U[i,:] o s^-1 o V[j,:] ) ∈ S_nc
 * ```
 * for every i,j and fixed permutation s (note here that since we are exhaustively searching over
 * all permutations s, we don't really have to invert this permutation and can use s in place of
 * s^-1). We can however precompute the number of inversions for every permutation in S_nc and store
 * them in the lookup table mem. We only need an appropriate encoding of the permutation σ ∈ S_nc as
 * an key (index) to mem array. We use a simple encoding is
 * ```
 *  key(σ) = nc**0 * σ(0) + nc**1 * σ(1) + ... + nc**(nc-1) * σ(nc-1) .
 * ```
 * Note however that this requires O(nc) operations to compute naively and thus as such would not
 * bring any improvement over `swap_bf()`. We can however compute the array
 * ```
 * key[i,j] = key( pos_U[i,:] o s o V[j,:] )
 * ```
 * dynamically. Indeed let s and s' be two subsequent permutations generated by Heap's algorithm
 * then there are two indices p!=q such that
 * ```
 * forall r=0,..,nc-1, r!=p, r!=q : s'(r) = s(r)
 * ```
 * and s'(p) = s(q) and s'(q) = s(p). Thus
 * ```
 *  key'[i,j] = key[i,j] - nc**a * pos_U[i,s(p)] - nc**b * pos_U[i,s(q)]
 *                       + nc**a * pos_U[i,s(q)] + nc**b * pos_U[i,s(p)]
 * ```
 * where a and b satisfy V[j,a] = p and V[j,b] = q and thus may be computed as
 * ```
 * a = pos_V[j,p], b = pos_V[j,q] .
 * ```
 * We can therefore update `key` matrix in O(nv**2) and since cost[i,j] = mem[key[i,j]] we can also
 * compute `cost` matrix in O(nv**2). In the actual implementation we use
 * ```
 *  key(σ) = σ(0) + 10 * σ(1) + ... + 10**(nc-1) * σ(nc-2)
 * ```
 * independent of nc (thus we only support nc <= 10) and use only the first nc-1 elements of
 * permutation σ as they uniquely define a permutation.
 *
 * @param pos_U pointer to the linearized position matrix of the 1st (U) election i.e. a matrix such
 * that pos_U[i,k] denotes the position of k-th candidate in the i-th vote in the U election.
 * NOTE: we assume that the elements of matrix are stored in column-major order.
 *
 * @param pos_V pointer to the linearized position matrix of the 2nd (V) election i.e. a matrix such
 * that pos_V[i,k] denotes the position of k-th candidate in the i-th vote in the V election.
 * NOTE: we assume that the elements of matrix are stored in column-major order.
 *
 * @param nv number of votes
 * @param nc number of candidates
 * @return isomorphic swap distance
 */
static int32_t
swap_bf_mem (const int32_t *pos_U, const int32_t *pos_V, const size_t nv, const size_t nc)
{
    // Ordinal Election matrix of the 2nd election (V) constructed from position matrix pos_V
    int32_t *V = calloc (nv * nc, sizeof (size_t));
    for (size_t i = 0; i < nv; i++)
        for (size_t j = 0; j < nc; j++)
            V[i + nv * pos_V[i + nv * j]] = j;

    // A lookup table storing inversion counts for every permutation of set {0,..,nc-1}. The key to
    // the table is an encoded permutation, see docstring of the `mem_inversion_cnt()` function.
    uint8_t *mem = calloc (pow10[nc - 1], sizeof (uint8_t));
    mem_inversion_cnt (nc, mem);

    // Cost matrix for LAP
    int32_t *cost = calloc (nv * nv, sizeof (int32_t));

    // Matrix of keys to the lookup table for every pair of votes. We utilize the fact that in every
    // iteration of Heap's algorihtm only two elements are swapped thus we can update key[i,j] in
    // O(1) and thus update cost[i,j] in O(1) instead of O(nc).
    size_t *key = calloc (nv * nv, sizeof (size_t));

    for (size_t i = 0; i < nv; i++)
        for (size_t j = 0; j < nv; j++)
        {
            for (size_t k = 0; k < nc - 1; k++)
                key[i * nv + j] += pos_U[i + nv * V[j + nv * k]] * pow10[k];

            cost[i * nv + j] = mem[key[i * nv + j]];
        }

    // Stack pointer and encoding of the stack in iterative version of Heap's algorithm. See:
    // https://en.wikipedia.org/wiki/Heap%27s_algorithm
    size_t alpha = 1, *stack = calloc (nc, sizeof (size_t));

    // Permutation array initialized to identity permutation
    size_t *sigma = calloc (nc, sizeof (size_t));
    for (size_t i = 0; i < nc; i++)
        sigma[i] = i;

    // Indices of elements of permutation sigma which are swapped in the given iteration of Heap's
    // algorithm
    size_t p = 0, q = 0;

    // Auxiliary variables required for J-V LAP algorithm
    int32_t *x = calloc (nv, sizeof (int32_t));
    int32_t *y = calloc (nv, sizeof (int32_t));

    int32_t best_res = lapi (nv, cost, x, y);

    while (alpha < nc)
    {
        if (stack[alpha] < alpha)
        {
            if (alpha % 2 == 0)
                p = 0, q = alpha;
            else
                p = alpha, q = stack[alpha];

            for (size_t i = 0; i < nv; i++)
            {
                register int32_t r1 = pos_U[i + nv * sigma[p]] - pos_U[i + nv * sigma[q]];

                for (size_t j = 0; j < nv; j++)
                {
                    size_t pos_p = pos_V[j + nv * p];
                    size_t pos_q = pos_V[j + nv * q];

                    key[i * nv + j] += r1 * ((pos_q < nc - 1) * pow10[pos_q] - (pos_p < nc - 1) * pow10[pos_p]);

                    // if (pos_p < nc - 1)
                    //     key[i * nv + j] -= r1 * pow10[pos_p];

                    // if (pos_q < nc - 1)
                    //     key[i * nv + j] += r1 * pow10[pos_q];

                    cost[i * nv + j] = mem[key[i * nv + j]];
                }
            }

            int32_t res = lapi (nv, cost, x, y);
            best_res = res < best_res ? res : best_res;

            swap (size_t, sigma[p], sigma[q]);
            stack[alpha]++;
            alpha = 1;
        }
        else
        {
            stack[alpha] = 0;
            alpha++;
        }
    }

    free (V);
    free (key);
    free (mem);
    free (cost);
    free (stack);
    free (sigma);
    free (x);
    free (y);

    return best_res;
}

#define d(i, j, k, l, m, n) ((pos_U[(i) + nv * (k)] - pos_U[(i) + nv * (l)]) * (pos_V[(j) + nv * (m)] - pos_V[(j) + nv * (n)]) < 0)

/**
 * @brief Implementation of a coordinate-descent heuristic (analogous to the Alternating Algorithm
 * for BAP problem, see 'bap.h' file) solving the following combinatorial optimization problem
 * equivalent to computing isomorphic swap distance
 * ```
 *  min_{v ∈ S_nv} min_{σ ∈ S_nc} sum_{i=0,..,nv-1} sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} d(i,v(i),k,l,σ(k),σ(l))
 * ```
 * where d(i,j,k,l,m,n) := 1/2 * { (pos_U[i,k] - pos_U[i,l]) * (pos_V[j,m] - pos_V[j,n]) < 0 }
 * ({...} denoting here the Iverson bracket), nc is the number of candidates, nv is the number of
 * voters, pos_U[i,k] denotes the position of k-th candidate in the i-th vote in the U election and
 * S_n denotes the set of all permutations of the set {0,..,n-1}. The algorithm actually solves
 * heuristically a Trilinear Assignment Problem (TAP)
 * ```
 *  min_{v ∈ S_nv} min_{σ ∈ S_nc} min_{π ∈ S_nc} sum_{i=0,..,nv-1} sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} d(i,v(i),k,l,σ(k),π(l))
 * ```
 * by the following procedure: we first sample uniformly two permutations from S_nc and initialize
 * v, σ, π so that σ and π are equal; we then perform a coordinate-descent by cyclically fixing two
 * of the three permutation, solving the corresponding Linear Assignment Problem (LAP) and updating
 * the non-fixed permutation, doing so until convergence. After that we return the smaller of the
 * values
 * ```
 *  sum_{i=0,..,nv-1} sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} d(i,v(i),k,l,σ(k),σ(l))
 *  sum_{i=0,..,nv-1} sum_{k=0,..,nc-1} sum_{l=0,..,nc-1} d(i,v(i),k,l,π(k),π(l))
 * ```
 * which provides a heuristic approximation of the isomorphic swap distance.
 *
 * @param pos_U pointer to the linearized position matrix of the 1st (U) election i.e. a matrix such
 * that pos_U[i,k] denotes the position of k-th candidate in the i-th vote in the U election.
 * NOTE: we assume that the elements of matrix are stored in column-major order.
 *
 * @param pos_V pointer to the linearized position matrix of the 2nd (V) election i.e. a matrix such
 * that pos_V[i,k] denotes the position of k-th candidate in the i-th vote in the V election.
 * NOTE: we assume that the elements of matrix are stored in column-major order.
 *
 * @param nv number of votes
 * @param nc number of candidates
 * @return heuristic approximation of isomorphic swap distance
 */
static int32_t
swap_aa (const int32_t *pos_U, const int32_t *pos_V, const size_t nv, const size_t nc)
{
    // Cost matrices for LAP
    int32_t *cost_nv = calloc (nv * nv, sizeof (int32_t));
    int32_t *cost_nc = calloc (nc * nc, sizeof (int32_t));

    // Auxiliary variables required for J-V LAP algorithm
    int32_t *rowsol_nv = calloc (nv, sizeof (int32_t));
    int32_t *colsol_nv = calloc (nv, sizeof (int32_t));
    int32_t *rowsol_nc = calloc (nc, sizeof (int32_t));
    int32_t *colsol_nc = calloc (nc, sizeof (int32_t));

    // Permutation arrays randomly initialized. Note that permutations `sigma_nc_1` and `sigma_nc_2`
    // are initialized to the same random permutation by design.
    size_t *sigma_nv = calloc (nv, sizeof (size_t));
    size_t *sigma_nc_1 = calloc (nc, sizeof (size_t));
    size_t *sigma_nc_2 = calloc (nc, sizeof (size_t));

    for (size_t i = 0; i < nv; i++)
        sigma_nv[i] = i;

    for (size_t i = 0; i < nc; i++)
        sigma_nc_1[i] = i;

    for (size_t i = nv - 1; i > 0; i--)
    {
        size_t j = rand () % i;
        swap (size_t, sigma_nv[i], sigma_nv[j]);
    }
    for (size_t i = nc - 1; i > 0; i--)
    {
        size_t j = rand () % i;
        swap (size_t, sigma_nc_1[i], sigma_nc_1[j]);
    }

    for (size_t i = 0; i < nc; i++)
        sigma_nc_2[i] = sigma_nc_1[i];

    // Minimum costs found in the previous and current iteration of coordinate-descent
    int32_t res_prev = 0, res_curr = -1;

    for (size_t k = 0; k < nc; k++)
        for (size_t l = 0; l < nc; l++)
            for (size_t i = 0; i < nv; i++)
                res_prev += d (i, sigma_nv[i], k, l, sigma_nc_1[k], sigma_nc_2[l]);

    // Coordinate-descent-like refinment
    while (1)
    {
        memset (cost_nv, 0, nv * nv * sizeof (*cost_nv));
        for (size_t l = 0; l < nc; l++)
            for (size_t k = 0; k < nc; k++)
                for (size_t i = 0; i < nv; i++)
                    for (size_t j = 0; j < nv; j++)
                        cost_nv[i * nv + j] += d (i, j, k, l, sigma_nc_1[k], sigma_nc_2[l]);

        res_curr = lapi (nv, cost_nv, rowsol_nv, colsol_nv);
        for (size_t i = 0; i < nv; i++)
            sigma_nv[i] = rowsol_nv[i];

        memset (cost_nc, 0, nc * nc * sizeof (*cost_nc));
        for (size_t i = 0; i < nc; i++)
            for (size_t j = 0; j < nc; j++)
                for (size_t l = 0; l < nc; l++)
                    for (size_t k = 0; k < nv; k++)
                        cost_nc[i * nc + j] += d (k, sigma_nv[k], i, l, j, sigma_nc_2[l]);

        res_curr = lapi (nc, cost_nc, rowsol_nc, colsol_nc);
        for (size_t i = 0; i < nc; i++)
            sigma_nc_1[i] = rowsol_nc[i];

        memset (cost_nc, 0, nc * nc * sizeof (*cost_nc));
        for (size_t i = 0; i < nc; i++)
            for (size_t j = 0; j < nc; j++)
                for (size_t l = 0; l < nc; l++)
                    for (size_t k = 0; k < nv; k++)
                        cost_nc[i * nc + j] += d (k, sigma_nv[k], l, i, sigma_nc_1[l], j);

        res_curr = lapi (nc, cost_nc, rowsol_nc, colsol_nc);
        for (size_t i = 0; i < nc; i++)
            sigma_nc_2[i] = rowsol_nc[i];

        if (res_prev == res_curr)
            break;

        res_prev = res_curr;
    }

    int32_t best_res_1 = 0;
    for (size_t k = 0; k < nc; k++)
        for (size_t l = k; l < nc; l++)
            for (size_t i = 0; i < nv; i++)
                best_res_1 += d (i, sigma_nv[i], k, l, sigma_nc_1[k], sigma_nc_1[l]);

    int32_t best_res_2 = 0;
    for (size_t k = 0; k < nc; k++)
        for (size_t l = k; l < nc; l++)
            for (size_t i = 0; i < nv; i++)
                best_res_2 += d (i, sigma_nv[i], k, l, sigma_nc_2[k], sigma_nc_2[l]);

    free (sigma_nv);
    free (sigma_nc_1);
    free (sigma_nc_2);
    free (cost_nv);
    free (cost_nc);
    free (rowsol_nv);
    free (rowsol_nc);
    free (colsol_nv);
    free (colsol_nc);

    return best_res_1 < best_res_2 ? best_res_1 : best_res_2;
}

// =================================================================================================
// =================================================================================================

static PyObject *
py_swap (PyObject *self, PyObject *args)
{
    PyObject *result = NULL; // Return object of the Python function
    PyObject *obj_X = NULL;  // Argument object for the 1st matrix
    PyObject *obj_Y = NULL;  // Argument object for the 2nd matrix
    // Options
    int method = 0;
    int repeats = 0;
    int seed = -1;

    // Parse arguments from Python to C

    if (!PyArg_ParseTuple (args, "OOiii", &obj_X, &obj_Y, &method, &repeats, &seed))
        return NULL;

    PyArrayObject *obj_cont_X = (PyArrayObject *)PyArray_ContiguousFromAny (obj_X, NPY_INT32, 0, 0);
    PyArrayObject *obj_cont_Y = (PyArrayObject *)PyArray_ContiguousFromAny (obj_Y, NPY_INT32, 0, 0);
    if (!obj_cont_X || !obj_cont_Y)
        return NULL;

    // Assert method is between 0 and N_METHODS-1

    const int N_METHODS = 2;

    if (method < 0 || method >= N_METHODS)
    {
        PyErr_Format (PyExc_ValueError, "expected method to be an int between 0 and %d", N_METHODS - 1);
        goto cleanup;
    }

    // Assert arrays are 2D

    if (PyArray_NDIM (obj_cont_X) != 2 || PyArray_NDIM (obj_cont_Y) != 2)
    {
        PyErr_Format (PyExc_ValueError, "expected 2-D arrays, got a %d-D and %d-D array",
                      PyArray_NDIM (obj_cont_X), PyArray_NDIM (obj_cont_Y));
        goto cleanup;
    }

    // Cast array objects to C arrays

    int32_t *pos_U = (int32_t *)PyArray_DATA (obj_cont_X);
    int32_t *pos_V = (int32_t *)PyArray_DATA (obj_cont_Y);
    if (pos_U == NULL || pos_V == NULL)
    {
        PyErr_SetString (PyExc_TypeError, "invalid array object");
        goto cleanup;
    }

    // Assert arrays have the same shape

    npy_intp rows_X = PyArray_DIM (obj_cont_X, 0), cols_X = PyArray_DIM (obj_cont_X, 1);
    npy_intp rows_Y = PyArray_DIM (obj_cont_Y, 0), cols_Y = PyArray_DIM (obj_cont_Y, 1);
    if (rows_X != rows_Y || cols_X != cols_Y)
    {
        PyErr_SetString (PyExc_TypeError, "expected arrays to have the same shape");
        goto cleanup;
    }

    // Variables required for C functions

    size_t nc = rows_X, nv = cols_X;
    int32_t ret = -1;

    // Set seed of the PRNG

    srand (seed > -1 ? seed : time (NULL));

    // Compute solution using C functions

    Py_BEGIN_ALLOW_THREADS;
    switch (method)
    {
    case 0:
        if (nc <= 10) // See NOTE in the docstring of mem_inversion_cnt()
            ret = swap_bf_mem (pos_U, pos_V, nv, nc);
        else
            ret = swap_bf (pos_U, pos_V, nv, nc);
        break;
    case 1:
        ret = swap_aa (pos_U, pos_V, nv, nc);
        for (int i = 0; i < repeats - 1; i++)
        {
            int32_t f = swap_aa (pos_U, pos_V, nv, nc);
            ret = ret > f ? f : ret;
        }
        break;
    default:
        break;
    }
    Py_END_ALLOW_THREADS;

    result = PyLong_FromLong (ret);

cleanup:
    Py_XDECREF ((PyObject *)obj_cont_X);
    Py_XDECREF ((PyObject *)obj_cont_Y);
    return result;
}

static PyMethodDef methods[] = {
    { "swap", (PyCFunction)py_swap, METH_VARARGS, "Swap distance.\n" },
    { NULL, NULL, 0, NULL }
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT, "_swap", "Swap distance.\n", -1, methods,
    NULL, NULL, NULL, NULL
};

PyMODINIT_FUNC
PyInit__swap (void)
{
    import_array ();
    return PyModule_Create (&moduledef);
}